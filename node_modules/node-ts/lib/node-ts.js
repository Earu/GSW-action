/**
 * @autor Niklas Mollenhauer <holzig@outlook.com>
 * @autor Tim Kluge <timklge@wh2.tu-dresden.de>
 */
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenType = exports.PermissionGroupTypes = exports.PermissionGroupDatabaseTypes = exports.ReasonIdentifier = exports.LogLevel = exports.TextMessageTargetMode = exports.CodecEncryptionMode = exports.Codec = exports.HostBannerMode = exports.HostMessageMode = exports.YesNo = exports.TeamSpeakClient = void 0;
const net = require("net");
const events_1 = require("events");
const util_1 = require("util");
const stringio_1 = require("@rauschma/stringio");
const queryStrings_1 = require("./queryStrings");
/**
 * Client that can be used to connect to a TeamSpeak server query API.
 */
class TeamSpeakClient extends events_1.EventEmitter {
    /**
     * Creates a new instance of TeamSpeakClient for a specific remote host:port.
     * @param {string = TeamSpeakClient.DefaultHost} host Remote host of the TeamSpeak server. Can be an IP address or a host name.
     * @param {number = TeamSpeakClient.DefaultPort} port TCP port of the server query instance of the remote host.
     * @constructor
     */
    constructor(host = TeamSpeakClient.DefaultHost, port = TeamSpeakClient.DefaultPort) {
        super();
        this.host = host;
        this.port = port;
        this.queue = [];
        this.isConnected = false;
    }
    connect() {
        this.isConnected = false;
        return new Promise((resolve, reject) => {
            this.socket = net.connect(this.port, this.host);
            this.socket.on("error", err => this.emit("error", err));
            // We'll try to reject the promise if the connection closes, to make sure
            // the promise gets rejected if we get an error while connecting.
            // (This will just do nothing if the promise is already fulfilled)
            this.socket.once("close", err => reject(err));
            this.socket.on("close", () => this.emit("close", this.queue));
            this.socket.on("connect", () => this.onConnect(resolve, reject));
        });
    }
    /**
     * Gets called on an opened connection
     */
    onConnect(connectionEstablished, error) {
        var e_1, _a;
        return __awaiter(this, void 0, void 0, function* () {
            const lineGenerator = stringio_1.chunksToLinesAsync(this.socket);
            let lineCounter = 0;
            try {
                for (var lineGenerator_1 = __asyncValues(lineGenerator), lineGenerator_1_1; lineGenerator_1_1 = yield lineGenerator_1.next(), !lineGenerator_1_1.done;) {
                    const lineWithNewLine = lineGenerator_1_1.value;
                    const line = stringio_1.chomp(lineWithNewLine).trim();
                    if (line === "")
                        continue;
                    ++lineCounter;
                    switch (lineCounter) {
                        case 1: {
                            if (line !== "TS3") {
                                this.isConnected = false;
                                error(new Error("Remove server is not a TS3 Query Server endpoint."));
                                return;
                            }
                            continue;
                        }
                        case 2:
                            // We have read a second non-empty line, so we are ready to take commands
                            this.isConnected = true;
                            connectionEstablished();
                            continue; // Welcome message, followed by empty line (which is skipped)
                        default: {
                            this.handleSingleLine(line);
                            this.checkQueue();
                        }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (lineGenerator_1_1 && !lineGenerator_1_1.done && (_a = lineGenerator_1.return)) yield _a.call(lineGenerator_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    handleSingleLine(line) {
        // Server answers with:
        // [- One line containing the answer ]
        // - "error id=XX msg=YY". ID is zero if command was executed successfully.
        if (line.startsWith("error")) {
            const errorResponse = line.substr("error ".length);
            const response = this.parseResponse(errorResponse);
            const executing = this._executing;
            if (response !== undefined && executing !== undefined) {
                const res = response.shift();
                if (res !== undefined) {
                    const currentError = {
                        id: res["id"] || 0,
                        msg: res["msg"] || ""
                    };
                    if (currentError.id !== 0)
                        executing.error = currentError;
                    if (executing.rejectFunction && executing.resolveFunction) {
                        //item: executing || null,
                        const e = executing;
                        const data = {
                            cmd: e.cmd,
                            options: e.options || [],
                            text: e.text || null,
                            parameters: e.parameters || {},
                            error: e.error || null,
                            response: e.response || null,
                            rawResponse: e.rawResponse || null
                        };
                        if (data.error && data.error.id !== 0)
                            executing.rejectFunction(data);
                        else
                            executing.resolveFunction(data);
                    }
                }
            }
            this._executing = undefined;
            this.checkQueue();
        }
        else if (line.startsWith("notify")) {
            const notificationResponse = line.substr("notify".length);
            const response = this.parseResponse(notificationResponse);
            const notificationName = notificationResponse.substr(0, notificationResponse.indexOf(" "));
            this.emit(notificationName, response);
        }
        else if (this._executing) {
            this._executing.rawResponse = line;
            this._executing.response = this.parseResponse(line);
        }
    }
    send(cmd, params = {}, options = []) {
        if (!cmd)
            return Promise.reject(new Error("Empty command"));
        if (!this.isConnected)
            return Promise.reject(new Error("Not connected to any server. Call \"connect()\" before sending anything."));
        let tosend = queryStrings_1.escape(cmd);
        for (const v of options)
            tosend += " -" + queryStrings_1.escape(v);
        for (const key in params) {
            if (!params.hasOwnProperty(key))
                continue;
            const value = params[key];
            if (!util_1.isArray(value)) {
                tosend += " " + queryStrings_1.escape(key.toString()) + "=" + queryStrings_1.escape(value.toString());
            }
        }
        // Handle multiple arrays correctly
        // Get all array in the params
        const arrayParamKeys = [];
        for (const key in params) {
            if (params.hasOwnProperty(key) && util_1.isArray(params[key]))
                arrayParamKeys.push(key);
        }
        if (arrayParamKeys.length > 0) {
            let escapedSegments = "";
            const firstArray = params[arrayParamKeys[0]];
            for (let i = 0; i < firstArray.length; ++i) {
                let segment = "";
                for (var key of arrayParamKeys) {
                    segment += queryStrings_1.escape(key) + "=" + queryStrings_1.escape(params[key][i]) + " ";
                }
                escapedSegments += segment.slice(0, -1) + "|";
            }
            if (escapedSegments.length > 0)
                tosend += " " + escapedSegments.slice(0, -1);
        }
        return new Promise((resolve, reject) => {
            this.queue.push({
                cmd: cmd,
                options: options,
                parameters: params,
                text: tosend,
                resolveFunction: resolve,
                rejectFunction: reject,
            });
            if (this.isConnected)
                this.checkQueue();
        });
    }
    subscribeChannelEvents(channelId) {
        return this.send("servernotifyregister", { event: "channel", channelId });
    }
    subscribeServerEvents() {
        return this.send("servernotifyregister", { event: "server" });
    }
    subscribeServerTextEvents() {
        return this.send("servernotifyregister", { event: "textserver" });
    }
    subscribeChannelTextEvents() {
        return this.send("servernotifyregister", { event: "textchannel" });
    }
    subscribePrivateTextEvents() {
        return this.send("servernotifyregister", { event: "textprivate" });
    }
    on(event, listener) {
        return super.on(event, listener);
    }
    once(event, listener) {
        return super.once(event, listener);
    }
    /**
     * Parses a query API response.
     */
    parseResponse(s) {
        const records = s.split("|");
        // Test this
        const response = records.map(currentItem => {
            const args = currentItem.split(" ");
            const thisrec = {};
            for (let v of args) {
                if (v.indexOf("=") <= -1) {
                    thisrec[v] = "";
                    continue;
                }
                const key = queryStrings_1.unescape(v.substr(0, v.indexOf("=")));
                const value = queryStrings_1.unescape(v.substr(v.indexOf("=") + 1));
                thisrec[key] = (parseInt(value, 10).toString() == value) ? parseInt(value, 10) : value;
            }
            return thisrec;
        });
        if (response.length === 0)
            return undefined;
        return response;
    }
    /**
     * Gets pending commands that are going to be sent to the server. Note that they have been parsed - Access pending[0].text to get the full text representation of the command.
     * @return {QueryCommand[]} Pending commands that are going to be sent to the server.
     */
    get pending() {
        return this.queue.slice(0);
    }
    /**
     * Clears the queue of pending commands so that any command that is currently queued won't be executed.
     * @return {QueryCommand[]} Array of commands that have been removed from the queue.
     */
    clearPending() {
        const q = this.queue;
        this.queue = [];
        return q;
    }
    /**
     * Checks the current command queue and sends them if needed.
     */
    checkQueue() {
        if (this._executing !== undefined)
            return;
        const executing = this.queue.shift();
        if (executing) {
            this._executing = executing;
            this.socket.write(this._executing.text + "\n");
        }
    }
    /**
     * Sets the socket to timeout after timeout milliseconds of inactivity on the socket. By default net.Socket do not have a timeout.
     */
    setTimeout(timeout) {
        this.socket.setTimeout(timeout, () => {
            this.socket.destroy();
            this.emit("timeout");
        });
    }
    unsetTimeout() {
        /*
         * If timeout is 0, then the existing idle timeout is disabled.
         * See: https://nodejs.org/api/net.html#net_socket_settimeout_timeout_callback
         */
        return this.setTimeout(0);
    }
}
exports.TeamSpeakClient = TeamSpeakClient;
TeamSpeakClient.DefaultHost = "localhost";
TeamSpeakClient.DefaultPort = 10011;
/*

    Enums imported from documentation.

*/
var YesNo;
(function (YesNo) {
    YesNo[YesNo["No"] = 0] = "No";
    YesNo[YesNo["Yes"] = 1] = "Yes";
})(YesNo = exports.YesNo || (exports.YesNo = {}));
var HostMessageMode;
(function (HostMessageMode) {
    /**
     * 1: display message in chatlog
     */
    HostMessageMode[HostMessageMode["LOG"] = 1] = "LOG";
    /**
     * 2: display message in modal dialog
     */
    HostMessageMode[HostMessageMode["MODAL"] = 2] = "MODAL";
    /**
     * 3: display message in modal dialog and close connection
     */
    HostMessageMode[HostMessageMode["MODALQUIT"] = 3] = "MODALQUIT";
})(HostMessageMode = exports.HostMessageMode || (exports.HostMessageMode = {}));
var HostBannerMode;
(function (HostBannerMode) {
    /**
     * 0: do not adjust
     */
    HostBannerMode[HostBannerMode["NOADJUST"] = 0] = "NOADJUST";
    /**
     * 1: adjust but ignore aspect ratio (like TeamSpeak 2)
     */
    HostBannerMode[HostBannerMode["IGNOREASPECT"] = 1] = "IGNOREASPECT";
    /**
     * 2: adjust and keep aspect ratio
     */
    HostBannerMode[HostBannerMode["KEEPASPECT"] = 2] = "KEEPASPECT";
})(HostBannerMode = exports.HostBannerMode || (exports.HostBannerMode = {}));
var Codec;
(function (Codec) {
    /**
     * 0: speex narrowband (mono, 16bit, 8kHz)
     */
    Codec[Codec["SPEEX_NARROWBAND"] = 0] = "SPEEX_NARROWBAND";
    /**
     * 1: speex wideband (mono, 16bit, 16kHz)
     */
    Codec[Codec["SPEEX_WIDEBAND"] = 1] = "SPEEX_WIDEBAND";
    /**
     * 2: speex ultra-wideband (mono, 16bit, 32kHz)
     */
    Codec[Codec["SPEEX_ULTRAWIDEBAND"] = 2] = "SPEEX_ULTRAWIDEBAND";
    /**
     * 3: celt mono (mono, 16bit, 48kHz)
     */
    Codec[Codec["CELT_MONO"] = 3] = "CELT_MONO";
})(Codec = exports.Codec || (exports.Codec = {}));
var CodecEncryptionMode;
(function (CodecEncryptionMode) {
    /**
     * 0: configure per channel
     */
    CodecEncryptionMode[CodecEncryptionMode["INDIVIDUAL"] = 0] = "INDIVIDUAL";
    /**
     * 1: globally disabled
     */
    CodecEncryptionMode[CodecEncryptionMode["DISABLED"] = 1] = "DISABLED";
    /**
     * 2: globally enabled
     */
    CodecEncryptionMode[CodecEncryptionMode["ENABLED"] = 2] = "ENABLED";
})(CodecEncryptionMode = exports.CodecEncryptionMode || (exports.CodecEncryptionMode = {}));
var TextMessageTargetMode;
(function (TextMessageTargetMode) {
    /**
     * 1: target is a client
     */
    TextMessageTargetMode[TextMessageTargetMode["CLIENT"] = 1] = "CLIENT";
    /**
     * 2: target is a channel
     */
    TextMessageTargetMode[TextMessageTargetMode["CHANNEL"] = 2] = "CHANNEL";
    /**
     * 3: target is a virtual server
     */
    TextMessageTargetMode[TextMessageTargetMode["SERVER"] = 3] = "SERVER";
})(TextMessageTargetMode = exports.TextMessageTargetMode || (exports.TextMessageTargetMode = {}));
var LogLevel;
(function (LogLevel) {
    /**
     * 1: everything that is really bad
     */
    LogLevel[LogLevel["ERROR"] = 1] = "ERROR";
    /**
     * 2: everything that might be bad
     */
    LogLevel[LogLevel["WARNING"] = 2] = "WARNING";
    /**
     * 3: output that might help find a problem
     */
    LogLevel[LogLevel["DEBUG"] = 3] = "DEBUG";
    /**
     * 4: informational output
     */
    LogLevel[LogLevel["INFO"] = 4] = "INFO";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
var ReasonIdentifier;
(function (ReasonIdentifier) {
    /**
     * 4: kick client from channel
     */
    ReasonIdentifier[ReasonIdentifier["CHANNEL"] = 4] = "CHANNEL";
    /**
     * 5: kick client from server
     */
    ReasonIdentifier[ReasonIdentifier["SERVER"] = 5] = "SERVER";
})(ReasonIdentifier = exports.ReasonIdentifier || (exports.ReasonIdentifier = {}));
var PermissionGroupDatabaseTypes;
(function (PermissionGroupDatabaseTypes) {
    /**
     * 0: template group (used for new virtual servers)
     */
    PermissionGroupDatabaseTypes[PermissionGroupDatabaseTypes["TEMPLATE"] = 0] = "TEMPLATE";
    /**
     * 1: regular group (used for regular clients)
     */
    PermissionGroupDatabaseTypes[PermissionGroupDatabaseTypes["REGULAR"] = 1] = "REGULAR";
    /**
     * 2: global query group (used for ServerQuery clients)
     */
    PermissionGroupDatabaseTypes[PermissionGroupDatabaseTypes["QUERY"] = 2] = "QUERY";
})(PermissionGroupDatabaseTypes = exports.PermissionGroupDatabaseTypes || (exports.PermissionGroupDatabaseTypes = {}));
var PermissionGroupTypes;
(function (PermissionGroupTypes) {
    /**
     * 0: server group permission
     */
    PermissionGroupTypes[PermissionGroupTypes["SERVER_GROUP"] = 0] = "SERVER_GROUP";
    /**
     * 1: client specific permission
     */
    PermissionGroupTypes[PermissionGroupTypes["GLOBAL_CLIENT"] = 1] = "GLOBAL_CLIENT";
    /**
     * 2: channel specific permission
     */
    PermissionGroupTypes[PermissionGroupTypes["CHANNEL"] = 2] = "CHANNEL";
    /**
     * 3: channel group permission
     */
    PermissionGroupTypes[PermissionGroupTypes["CHANNEL_GROUP"] = 3] = "CHANNEL_GROUP";
    /**
     * 4: channel-client specific permission
     */
    PermissionGroupTypes[PermissionGroupTypes["CHANNEL_CLIENT"] = 4] = "CHANNEL_CLIENT";
})(PermissionGroupTypes = exports.PermissionGroupTypes || (exports.PermissionGroupTypes = {}));
var TokenType;
(function (TokenType) {
    /**
     * 0: server group token (id1={groupID} id2=0)
     */
    TokenType[TokenType["SERVER_GROUP"] = 0] = "SERVER_GROUP";
    /**
     * 1: channel group token (id1={groupID} id2={channelID})
     */
    TokenType[TokenType["CHANNEL_GROUP"] = 1] = "CHANNEL_GROUP";
})(TokenType = exports.TokenType || (exports.TokenType = {}));
